import sb.parse_utils # for sb.parse_utils.init(...)
import io, tarfile    # if the output parameter is used
import json           # to parse the Result JSON
import re             # to match the Result line
from typing import Optional

VERSION: str = "2023/08/01"
"""identify the version of the parser, e.g. '2022/08/15'"""

FINDINGS: set[str] = {"arithmetic", "reentrancy", "access_control", 
                      "denial_of_service", "front_running", 
                      "time_manipulation", "unchecked_low_level_calls"}
"""set of strings: all possible findings, of which 'findings' below will be a subset"""


def parse(
    exit_code: Optional[int], log: list[str], output: Optional[bytes]
) -> tuple[list[dict[str, object]], set[str], set[str], set[str]]:
    """
    Analyse the result of the tool tun.

    :param exit_code: int|None, exit code of Docker run (None=timeout)
    :param log: list[str], stdout/stderr of Docker run
    :param output: bytes, tar archive of files generated by the tool (if specified in config.yaml)

    :return: tuple[findings: list[dict], infos: set[str], errors: set[str], fails: set[str]]
      findings identifies the major observations of the tool,
      infos contains any messages generated by the tool that might be of interest,
      errors lists the error messages deliberately generated by the tool,
      fails lists exceptions and other events not expected by the tool,
      analysis contains any analysis results worth reporting
    """

    findings, infos = [], set()
    errors, fails = sb.parse_utils.errors_fails(exit_code, log)
    # Parses the output for common Python/Java/shell exceptions (returned in 'fails')
    
    try:
        with io.BytesIO(output) as o, tarfile.open(fileobj=o) as tar:
            # access specific file
            output = tar.extractfile("output.json").read()
            
            result_data = json.loads(output)
                
            if "messages" in result_data:
                infos.add(result_data["messages"])
            
            if "summaries" in result_data:
                if result_data["summaries"] is None:
                    errors.add("no result")
                else:
                    for summary in result_data["summaries"]:
                        if summary.get("vulnerability", 0) == 1:
                            vuln_type = summary.get("type", "unknown")
                            
                            # Collect all code lines from vulnerable results
                            code_lines = []
                            for result in summary.get("results", []):
                                if result.get("vulnerability", 0) == 1:
                                    code_lines.extend(result.get("code_lines", []))

                            if not code_lines:
                                finding = {
                                    "name": vuln_type
                                }
                            else:
                            # For one findings entry we just take min and max line number and assume all lines in between are affected
                                finding = {
                                    "name": vuln_type,
                                    "line": min(code_lines) if code_lines else None,
                                    "line_end": max(code_lines) if code_lines else None
                                }
                            findings.append(finding)
    except Exception as e:
        fails.add(f"error parsing results: {e}")

    return findings, infos, errors, fails

    """
    findings is a list of issues. Each issue is a dict with the following fields.
    name: str
        mandatory. Identifies the type of issue
    filename: str
        optional. Path of file processed. As this is the path within
        the docker image, it will be replaced by the external filename,
        after parsing.
    contract: str
        optional. Name of contract within the file (for source code)
    function: str
        optional. Name/header/signature of function containing the issue
    line: int
        optional. Line number of issue in source code, starting with 1
    column: int
        optional. Column of issue in source code, starting with 1
    line_end: int
        optional. Last line of the source code, where issue occurs.
    column_end: int
        optional. Last column of the source code, where issue occurs.
    address: int
        optional. Address of instruction in the bytecode, where issue occurs, starting with 0
    address_end: int
        optional. Address of last instruction in the bytecode, where issue occurs, starting with 0
    exploit: Any
        optional. Information on a potential exploit, e.g. a list of transactions
    level: str
        optional. type of issue, e.g. recommendation, warning, error
    severity: str
        optional. Severity of issue, e.g. low, medium, high
    message: str
        optional. Description of the issue

    If missing, the fields severity, classification, method, descr_short,
    descr_long will be taken from the file findings.yaml in the tools
    directory (if it exists), with "name" serving as the key.
    """

# Example of the result JSON:
# {
#   "summaries": [
#     {
#       "type": "reentrancy",
#       "graph_runtime": 2244,
#       "node_runtime": 1075,
#       "number_of_bug_node": 13,
#       "vulnerability": 1,
#       "number_of_normal_node": 2,
#       "results": [
#         {
#           "id": 1,
#           "code_lines": [
#             9
#           ],
#           "vulnerability": 1
#         },
#         {
#           "id": 2,
#           "code_lines": [
#             10
#           ],
#           "vulnerability": 1
#         },
#         {
#           "id": 5,
#           "code_lines": [
#             15,
#             16,
#             17,
#             18
#           ],
#           "vulnerability": 1
#         },
#         {
#           "id": 6,
#           "code_lines": [
#             19
#           ],
#           "vulnerability": 1
#         },
#         {
#           "id": 7,
#           "code_lines": [
#             22
#           ],
#           "vulnerability": 1
#         },
#         {
#           "id": 8,
#           "code_lines": [
#             22
#           ],
#           "vulnerability": 1
#         },
#         {
#           "id": 9,
#           "code_lines": [
#             23
#           ],
#           "vulnerability": 1
#         }
#       ]
#     }
#   ],
#   "messages": "OK"
# }
