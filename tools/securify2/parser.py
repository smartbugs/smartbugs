import sb.parse_utils


VERSION: str = "2025-09-12"

FINDINGS: set[str] = {
    "Transaction Order Affects Ether Amount",  # 1
    "Transaction Order Affects Ether Receiver",  # 2
    "Transaction Order Affects Execution of Ether Transfer",  # 3
    "Unrestricted write to storage",  # 4
    "Right-to-left-override pattern",  # 5
    "State Variable Shadowing",  # 6
    "Unrestricted call to selfdestruct",  # 7
    "Uninitialized State Variable",  # 8 #9
    "Delegatecall or callcode to unrestricted address",  # 10
    "Gas-dependent Reentrancy",  # 11 DAO
    "Reentrancy with constant gas",  # 11 DAO
    "Incorrect ERC20 Interface",  # 12
    "Incorrect ERC721 Interface",  # 13
    "Dangerous Strict Equalities",  # 14
    "Locked Ether",  # 15
    "No-Ether-Involved Reentrancy",  # 16
    "Possibly unsafe usage of tx-origin",  # 17
    "Unhandled Exception",  # 18
    "Unrestricted Ether Flow",  # 19
    "Arbitrary Send",  # 19
    "Uninitialized Local Variables",  # 20
    "Unused Return Pattern",  # 21
    "Shadowed Builtin",  # 22
    "Shadowed Local Variable",  # 23
    "Call to Default Constructor",  # 24
    "External call in loop",  # 25
    "Benign Reentrancy",  # 26
    "Usage of block timestamp",  # 27
    "Assembly Usage",  # 28
    "ERC20 Indexed Pattern",  # 29
    "Low Level Calls",  # 30
    "Solidity Naming Convention",  # 31
    "Solidity pragma directives",  # 32
    "Unused State Variable",  # 33
    "Too Many Digit Literals",  # 34
    "Constable State Variables",  # 35
    "External Calls of Functions",  # 36
    "State variables default visibility",  # 37
    "Repeated Call to Untrusted Contract",
    "Dos gas limit pattern",
    "Unused variables pattern",
    "Taint Analysis for PASS Project",
    "Multiplication after division",
    "Missing Input Validation",
}

FIELDS = {
    "Severity": "severity",
    "Pattern": "name",
    "Description": "message",
    "Type": "type",
    "Contract": "contract",
    "Line": "line",
    "Source": "source",
    "Traceback (most recent call last)": "traceback",
}


def parse(
    exit_code: int, log: list[str], output: bytes
) -> tuple[list[dict], set[str], set[str], set[str]]:
    """
    Analyse the result of the tool tun.

    :param exit_code: int|None, exit code of Docker run (None=timeout)
    :param log: list[str], stdout/stderr of Docker run
    :param output: bytes, tar archive of files generated by the tool (if specified in config.yaml)

    :return: tuple[findings: list[dict], infos: set[str], errors: set[str], fails: set[str]]
      findings identifies the major observations of the tool,
      infos contains any messages generated by the tool that might be of interest,
      errors lists the error messages deliberately generated by the tool,
      fails lists exceptions and other events not expected by the tool,
      analysis contains any analysis results worth reporting
    """

    findings: list[dict] = []
    infos: set[str] = set()
    errors, fails = sb.parse_utils.errors_fails(exit_code, log)

    finding: dict = {}
    last_key: str = ""
    for line in sb.parse_utils.discard_ansi(log):
        parts = line.split(":")
        key = FIELDS.get(parts[0], None)
        if key and len(parts) > 1:
            val = parts[1].strip()
            if key == "line":
                finding[key] = int(val)
            elif key == "source":
                finding[key] = []
            elif key == "traceback":
                break
            else:
                finding[key] = val
            last_key = key
        elif line.startswith("             ") and last_key == "message":
            finding["message"] += " " + val
        elif (
            line.startswith(">")
            and last_key == "source"
            and isinstance(finding.get("source"), list)
        ):
            finding["source"].append(line)
        else:
            if finding:
                findings.append(finding)
                finding, last_key = {}, None
            if line.strip():
                infos.add(line)

    if finding:
        findings.append(finding)
    return findings, infos, errors, fails
    """
    findings is a list of issues. Each issue is a dict with the following fields.
    name: str
        mandatory. Identifies the type of issue
    filename: str
        optional. Path of file processed. As this is the path within
        the docker image, it will be replaced by the external filename,
        after parsing.
    contract: str
        optional. Name of contract within the file (for source code)
    function: str
        optional. Name/header/signature of function containing the issue
    line: int
        optional. Line number of issue in source code, starting with 1
    column: int
        optional. Column of issue in source code, starting with 1
    line_end: int
        optional. Last line of the source code, where issue occurs.
    column_end: int
        optional. Last column of the source code, where issue occurs.
    address: int
        optional. Address of instruction in the bytecode, where issue occurs, starting with 0
    address_end: int
        optional. Address of last instruction in the bytecode, where issue occurs, starting with 0
    exploit: Any
        optional. Information on a potential exploit, e.g. a list of transactions
    level: str
        optional. type of issue, e.g. recommendation, warning, error
    severity: str
        optional. Severity of issue, e.g. low, medium, high
    message: str
        optional. Description of the issue

    If missing, the fields severity, classification, method, descr_short,
    descr_long will be taken from the file findings.yaml in the tools
    directory (if it exists), with "name" serving as the key.
    """
